#include <openssl/bn.h>
#include <openssl/rand.h>
#include <openssl/evp.h>
#include <openssl/core_names.h>
#include "utils.h"
#include <string.h>

#define NAOR_BITS 2048


/***
 * Returns the R number generated by Bob (3n bits)
*/
BIGNUM* gen_R(){
    BIGNUM* x = BN_new();
    BN_CTX* ctx = BN_CTX_new();

    BN_rand_ex(x,3*NAOR_BITS,0,0,0,ctx);

    return x;
}

/**
 * Alice generates the Y number and runs the PRNG
*/
BN_pair* naor_commit(char b,BIGNUM* r){

    BIGNUM* y = BN_new();
    BIGNUM* random_num = BN_new();
    BIGNUM* vrf = BN_new();

    BN_CTX* ctx = BN_CTX_new();

    BN_pair* ret = (BN_pair*) malloc(sizeof(BN_pair));

    unsigned char* y_buf;
    unsigned char* random_num_buf;

    // Prepare DRBG
    EVP_RAND* rand = EVP_RAND_fetch(NULL,"CTR-DRBG",NULL);
    EVP_RAND_CTX *rctx = EVP_RAND_CTX_new(rand,NULL);
    EVP_RAND_free(rand);

    unsigned char bytes[3*NAOR_BITS/8];
    OSSL_PARAM params[2], *p = params;
    unsigned int strength = 128;

    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_DRBG_PARAM_CIPHER,
                                        SN_aes_256_ctr, 0);
    *p = OSSL_PARAM_construct_end();

    EVP_RAND_instantiate(rctx,0,0,NULL,0,params);

    // Generate y
    BN_rand_ex(y,NAOR_BITS,0,0,0,ctx);

    // Seed and run PRNG
    y_buf = (unsigned char*) malloc(BN_num_bytes(y));
    random_num_buf = (unsigned char*) malloc(3*NAOR_BITS/8);
    BN_bn2bin(y,y_buf);
    memset(y_buf,0,NAOR_BITS/8);

    // Seed and generate
    EVP_RAND_reseed(rctx,1,NULL,0,y_buf,NAOR_BITS/8);
    EVP_RAND_generate(rctx, bytes, sizeof(bytes), strength, 0, NULL, 0);
    BN_bin2bn(bytes,3*NAOR_BITS/8,random_num);

    EVP_RAND_uninstantiate(rctx);
    EVP_RAND_instantiate(rctx,0,0,NULL,0,params);
    EVP_RAND_reseed(rctx,1,NULL,0,y_buf,NAOR_BITS/8);
    EVP_RAND_generate(rctx, bytes, sizeof(bytes), strength, 0, NULL, 0);
    BN_bin2bn(bytes,3*NAOR_BITS/8,vrf);

    if (BN_cmp(vrf,random_num) != 0){
        puts("Error in rand generation");
        printf("%s\n",BN_bn2hex(vrf));
        printf("%s\n",BN_bn2hex(random_num));
        exit(-1);
    }
    else{
        puts("EQUAL");
    }

    /*RAND_seed( (void*) y_buf, BN_num_bytes(y));

    if ( RAND_bytes(  random_num_buf, NAOR_BITS/8*3) != 1){
        puts("Error in random number generation!");
        exit(-1);
    }
    BN_bin2bn(random_num_buf,3*NAOR_BITS/8,random_num);

    RAND_seed( (void*) y_buf, BN_num_bytes(y));
    if ( RAND_bytes(  random_num_buf, NAOR_BITS/8*3) != 1){
        puts("Error in random number generation!");
        exit(-1);
    }*/

    // xor if needed
    if (b==1){
        ret->x = random_num;
    }
    else{
        ret->x = BN_xor(random_num,r);
    }

    ret->y = y;
    return ret;
}

bool naor_verify(char claimed, BIGNUM* x, BIGNUM* y,BIGNUM* r){

    unsigned char* random_num_buf =(unsigned char*) malloc(NAOR_BITS/8*3);
    unsigned char* y_buf = (unsigned char*) malloc(NAOR_BITS/8);
    BIGNUM* random_num = BN_new();
    BIGNUM* xored = BN_new();

    BN_bn2bin(y,y_buf);

    // Prepare DRBG
    EVP_RAND* rand = EVP_RAND_fetch(NULL,"CTR-DRBG",NULL);
    EVP_RAND_CTX *rctx = EVP_RAND_CTX_new(rand,NULL);
    EVP_RAND_free(rand);

    unsigned char bytes[NAOR_BITS/8];
    OSSL_PARAM params[2], *p = params;
    unsigned int strength = 128;

    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_DRBG_PARAM_CIPHER, 
                                        SN_aes_256_ctr, 0);
    *p = OSSL_PARAM_construct_end();

    EVP_RAND_instantiate(rctx,NAOR_BITS/8,0,NULL,0,params);

    // Seed and generate
    EVP_RAND_reseed(rctx,0,NULL,0,random_num_buf,3*NAOR_BITS/8);
    EVP_RAND_generate(rctx, bytes, sizeof(bytes), strength, 0, NULL, 0);

    RAND_seed( (void*) y_buf, NAOR_BITS/8);
    RAND_bytes(  random_num_buf, NAOR_BITS/8*3);
    BN_bin2bn(random_num_buf,3*NAOR_BITS/8,random_num);

    if (claimed == 1){

        return BN_cmp(random_num,x) == 0;
    }
    
    if (claimed == 0){
        xored = BN_xor(random_num,r);
        return BN_cmp(xored,x) == 0;
    }
}